        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Schedule class / undone Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="undone" data-type="Schedule">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../undone.html">undone</a> &rsaquo; <a href="../undone/Schedule.html">Schedule</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Schedule</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An asynchronous schedule of actions.</p>
<p>A schedule is a function that can be <a class="crossref" href="../undone/Schedule.html#call">call</a>ed with <a class="crossref" href="../undone/Action.html">Action</a>s.  The order 
of such calls is preserved in a history to allow for <a class="crossref" href="../undone/Schedule.html#undo">undo</a> and <a class="crossref" href="../undone/Schedule.html#redo">redo</a>.  An 
action may be scheduled at any time; if the schedule is not <a class="crossref" href="../undone/Schedule.html#busy">busy</a> then it 
will be called immediately, otherwise it will be queued to be called as soon 
as possible.  Methods to change the history such as <a class="crossref" href="../undone/Schedule.html#undo">undo</a> and <a class="crossref" href="../undone/Schedule.html#redo">redo</a> can 
<em>not</em> be invoked when the schedule is <a class="crossref" href="../undone/Schedule.html#busy">busy</a>.  This ensures that all queued 
actions are called and the schedule reaches an idle state before the history 
may be modified.  Each schedule is a state machine, and its <a class="crossref" href="../undone/Schedule.html#states">states</a> are 
observable as a stream; this provides a convenient means to connect a user 
interface to the history control methods.</p>
<pre class="source">
class Schedule {
 /// A schedule is idle (not busy).
 static const String STATE_IDLE = 'IDLE';
 /// A schedule is busy executing a new action.
 static const String STATE_CALL = 'CALL';
 /// A schedule is busy flushing pending actions.
 static const String STATE_FLUSH = 'FLUSH';
 /// A schedule is busy performing a redo operation.
 static const String STATE_REDO = 'REDO';
 /// A schedule is busy performing an undo operation.
 static const String STATE_UNDO = 'UNDO';
 /// A schedule is busy performing a to operation.
 static const String STATE_TO = 'TO';
 /// A schedule has an error.
 static const String STATE_ERROR = 'ERROR';
 
 final _actions = new List&lt;Action&gt;();
 // Actions that are called while this schedule is busy are pending to be done.
 final _pending = new List&lt;Action&gt;();
 int _nextUndo = -1;
 String _currState = STATE_IDLE;
 var _err;
 
 /// Whether or not this schedule is busy performing another action.
 /// This is always `true` when called from any continuations that are
 /// chained to Futures returned by methods on this schedule.
 /// This is also `true` if this schedule has an [error].
 bool get busy =&gt; _state != STATE_IDLE;
 
 /// Whether or not this schedule can be [clear]ed at the present time.
 bool get canClear =&gt; !busy || hasError;
 
 bool get _canRedo =&gt; _nextUndo &lt; _actions.length - 1;
 /// Whether or not the [redo] method may be called at the present time.
 bool get canRedo =&gt; !busy &amp;&amp; _canRedo;
 
 bool get _canUndo =&gt; _nextUndo &gt;= 0;
 /// Whether or not the [undo] method may be called at the present time.
 bool get canUndo =&gt; !busy &amp;&amp; _canUndo;
 
 /// Whether or not this schedule has an [error].
 bool get hasError =&gt; _state == STATE_ERROR;
   
 /// The current error, if [hasError] is `true`.  This schedule will remain
 /// [busy] for as long as this schedule [hasError].  You may [clear] this
 /// schedule after dealing with the error condition in order to use it again.
 get error =&gt; _err;
 set _error(e) {
   _err = e;
   _state = STATE_ERROR;
 }
 
 // The current state of this schedule.
 String get _state =&gt; _currState;
 set _state(String nextState) {
   if (nextState != _currState &amp;&amp; _currState != STATE_ERROR) {
     _currState = nextState;
     _log(() =&gt; '--- enter state ---');
     if (_states.hasListener) _states.add(_currState);
   }
 }
   
 final _states = new StreamController&lt;String&gt;.broadcast();
 /// An observable stream of this schedule's state transitions.
 Stream&lt;String&gt; get states =&gt; _states.stream;
     
 /// Schedule the given [action] to be called.  If this schedule is not [busy], 
 /// the action will be called immediately.  Else, the action will be deferred 
 /// in order behind any other pending actions to be called once this schedule 
 /// reaches an idle state.
 Future call(Action action) {
   if (hasError) {
     _error = new StateError('Cannot call if Schedule.hasError.');
     return new Future.error(error); 
   }
   if (_actions.contains(action) || _pending.contains(action)) {
     _error = new StateError('Cannot call $action &gt;1 time on same schedule.');
     return new Future.error(error);
   }
   if (busy) {
     _log(() =&gt; 'defer $action');
     _pending.add(action);
     return action._defer();
   }
   _state = STATE_CALL;
   return _do(action);
 }
 
 /// Clears this schedule if [canClear] is `true` at this time and returns
 /// `true` if the operation succeeds or `false` if it does not succeed.
 bool clear() {
   if (!canClear) return false;
   _log(() =&gt; 'clear');
   _actions.clear();
   _pending.clear();
   _nextUndo = -1;
   // Force the state back to STATE_IDLE even if we were in STATE_ERROR.
   if (_currState != STATE_IDLE) {
     _currState = STATE_IDLE;
     if (_states.hasListener) _states.add(_currState);
   }
   _err = null;
   return true;
 }
 
 Future _do(action) {    
   var completer = new Completer();
   // Truncate the end of list (redo actions) when adding a new action.
   if (_nextUndo &gt;= 0) _actions.removeRange(_nextUndo, _actions.length - 1);
   _actions.add(action);        
   _nextUndo++;
   _log(() =&gt; 'execute $action [$_nextUndo]');
   action._execute()
     .then((result) {
       _log(() =&gt; '$action complete w/ $result');
       action._result = result;
       // Flush any pending action calls that were deferred as we did this 
       // action.  Also flush if we see STATE_ERROR, to ensure that pending
       // actions that were called prior to the error receive a completion.
       if (_state == STATE_CALL || _state == STATE_ERROR) {
         completer.future.whenComplete(_flush);        
       }
       // Complete the result before we flush pending and transition to idle.
       // This ensures 2 things:
       //    1) The continuations of the action see the state as the result of 
       //       this action and _not_ the state of further pending actions.
       //    2) The order of pending actions is preserved as the user is not
       //       able to undo or redo (busy == true) in continuations.
       completer.complete(result);        
     })
     .catchError((e) {
       _error = e;
       completer.completeError(e);
     });    
   return completer.future;    
 }
 
 Future _flush() {
   // If nothing is pending then complete immediate and go to STATE_IDLE.
   if (_pending.isEmpty) {
     _state = STATE_IDLE;
     return new Future.value();
   }
   _state = STATE_FLUSH;
   // Copy _pending actions to a new list to iterate because new actions 
   // may be added to _pending while we are iterating.
   final _flushing = _pending.toList();
   _pending.clear();
   _log(() =&gt; 'flushing ${_flushing.length} actions');
   return Future
     .forEach(_flushing, (action) =&gt; _do(action)) 
     .then((_) {        
       // If we get new _pending actions during flush we want to flush again.
       if (!_pending.isEmpty) {
         _log(() =&gt; 'new actions pending - flushing again');
         return _flush();
       }
       else {
         _log(() =&gt; 'flush complete');
         _state = STATE_IDLE;
       }        
     })
     // The action will complete the error to its continuations, but we will 
     // also receive it here in order to transition to the error state.
     .catchError((e) =&gt; _error = e);
 }
 
 void _log(String message()) {
   // Assert will be stripped in 'production' mode; the result is that all
   // logging code should be removed as dead code by the tree shaking.
   assert(() {
     _logger.fine('[${_state}]: ${message()}');
     return true;
   });
 }
 
 /// Redo the next action to be redone in this schedule, if any.
 /// Completes `true` if an action was redone or else completes `false`.
 Future&lt;bool&gt; redo() { 
   var completer = new Completer&lt;bool&gt;();
   if(!_canRedo || !(_state == STATE_TO || _state == STATE_IDLE)) {
     _log(() =&gt; 'can not redo');
     completer.complete(false);
   } else {
     if (_state == STATE_IDLE) _state = STATE_REDO;
     final action = _actions[++_nextUndo];
     _log(() =&gt; 'execute ${action} [${_nextUndo-1}]');
     action._execute()
       .then((result) {
         _log(() =&gt; '${action} execute complete w/ $result');
         action._result = result;
         // Don't flush if we are in STATE_TO, it will flush when it is done.
         if (_state == STATE_REDO) completer.future.whenComplete(_flush);
         // Complete before we flush pending and transition to idle.
         // This ensures that continuations of redo see the state as the 
         // result of redo and _not_ the state of further pending actions. 
         completer.complete(true);          
       })
       .catchError((e) {
         _error = e;
         completer.completeError(e);
       });
   }
   return completer.future;
 }
 
 /// Undo or redo all ordered actions in this schedule until the given [action] 
 /// is done.  The state of the schedule after this operation is equal to the 
 /// state upon completion of the given action. Completes `false` if any undo 
 /// or redo operations performed complete `false`, if the schedule does not 
 /// contain the given action, or if the schedule is [busy].
 Future&lt;bool&gt; to(action) { 
   var completer = new Completer();    
   if (!_actions.contains(action) || 
       !(_state == STATE_TO || _state == STATE_IDLE)) {
     completer.complete(false);
   } else {      
     _state = STATE_TO;
     _to(action, completer);
   }
   return completer.future;
 }
 
 void _to(action, completer) {
   final handleError = (e) { _error = e; completer.completeError(e); };
   final int actionIndex = _actions.indexOf(action);
   if (actionIndex == _nextUndo) {
     completer.future.whenComplete(_flush);
     // Complete before we flush pending and transition to idle.
     // This ensures that continuations of 'to' see the state as the 
     // result of 'to' and _not_ the state of further pending actions.
     completer.complete(true);
   } else if (actionIndex &lt; _nextUndo) {
     // Undo towards the desired action.
     undo()
       .then((success) {
         if (!success) completer.complete(false);
         else _to(action, completer);
       })
       .catchError(handleError);
   } else {
     // Redo towards the desired action.
     redo()
       .then((success) {
         if (!success) completer.complete(false); 
         else _to(action, completer);
       })
       .catchError(handleError);
   }
 }
 
 /// Undo the next action to be undone in this schedule, if any.
 /// Completes `true` if an action was undone or else completes `false`.
 Future&lt;bool&gt; undo() { 
   var completer = new Completer&lt;bool&gt;();
   if(!_canUndo || !(_state == STATE_TO || _state == STATE_IDLE)) {
     _log(() =&gt; 'can not undo');
     completer.complete(false);
   } else {
     if (_state == STATE_IDLE) _state = STATE_UNDO;      
     final action = _actions[_nextUndo--];
     _log(() =&gt; 'unexecute ${action} [${_nextUndo+1}]');
     action._unexecute()
       .then((_) {
         _log(() =&gt; '${action} unexecute complete');
         // Don't flush if we are in STATE_TO, it will flush when it is done.
         if (_state == STATE_UNDO) completer.future.whenComplete(_flush);
         // Complete before we flush pending and transition to idle.
         // This ensures that continuations of undo see the state as the 
         // result of undo and _not_ the state of further pending actions. 
         completer.complete(true);          
       })
       .catchError((e) {
         _error = e;
         completer.completeError(e);
       });
   }
   return completer.future;
 }
 
 /// Wait for this schedule to reach the given [state].
 /// Completes on the next transition to the given state, or immediately if the 
 /// state is the current state of this schedule.
 Future&lt;String&gt; wait(String state) {
   // TODO(rms): validate that state is one of the possible values; oh enum!
   if (_state == state) return new Future.value(_state);
   return states.firstWhere((s) =&gt; s == state);
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="STATE_CALL">
<button class="show-code">Code</button>
const String         <strong>STATE_CALL</strong> <a class="anchor-link"
            href="#STATE_CALL"
            title="Permalink to Schedule.STATE_CALL">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy executing a new action.</p>
<pre class="source">
static const String STATE_CALL = 'CALL'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_ERROR">
<button class="show-code">Code</button>
const String         <strong>STATE_ERROR</strong> <a class="anchor-link"
            href="#STATE_ERROR"
            title="Permalink to Schedule.STATE_ERROR">#</a>
        </h4>
        <div class="doc">
<p>A schedule has an error.</p>
<pre class="source">
static const String STATE_ERROR = 'ERROR'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_FLUSH">
<button class="show-code">Code</button>
const String         <strong>STATE_FLUSH</strong> <a class="anchor-link"
            href="#STATE_FLUSH"
            title="Permalink to Schedule.STATE_FLUSH">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy flushing pending actions.</p>
<pre class="source">
static const String STATE_FLUSH = 'FLUSH'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_IDLE">
<button class="show-code">Code</button>
const String         <strong>STATE_IDLE</strong> <a class="anchor-link"
            href="#STATE_IDLE"
            title="Permalink to Schedule.STATE_IDLE">#</a>
        </h4>
        <div class="doc">
<p>A schedule is idle (not busy).</p>
<pre class="source">
static const String STATE_IDLE = 'IDLE'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_REDO">
<button class="show-code">Code</button>
const String         <strong>STATE_REDO</strong> <a class="anchor-link"
            href="#STATE_REDO"
            title="Permalink to Schedule.STATE_REDO">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy performing a redo operation.</p>
<pre class="source">
static const String STATE_REDO = 'REDO'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_TO">
<button class="show-code">Code</button>
const String         <strong>STATE_TO</strong> <a class="anchor-link"
            href="#STATE_TO"
            title="Permalink to Schedule.STATE_TO">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy performing a to operation.</p>
<pre class="source">
static const String STATE_TO = 'TO'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_UNDO">
<button class="show-code">Code</button>
const String         <strong>STATE_UNDO</strong> <a class="anchor-link"
            href="#STATE_UNDO"
            title="Permalink to Schedule.STATE_UNDO">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy performing an undo operation.</p>
<pre class="source">
static const String STATE_UNDO = 'UNDO'
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="busy">
<button class="show-code">Code</button>
final bool         <strong>busy</strong> <a class="anchor-link"
            href="#busy"
            title="Permalink to Schedule.busy">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule is busy performing another action.
This is always <code>true</code> when called from any continuations that are
chained to Futures returned by methods on this schedule.
This is also <code>true</code> if this schedule has an <a class="crossref" href="../undone/Schedule.html#error">error</a>.</p>
<pre class="source">
bool get busy =&gt; _state != STATE_IDLE;
</pre>
</div>
</div>
<div class="field"><h4 id="canClear">
<button class="show-code">Code</button>
final bool         <strong>canClear</strong> <a class="anchor-link"
            href="#canClear"
            title="Permalink to Schedule.canClear">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule can be <a class="crossref" href="../undone/Schedule.html#clear">clear</a>ed at the present time.</p>
<pre class="source">
bool get canClear =&gt; !busy || hasError;
</pre>
</div>
</div>
<div class="field"><h4 id="canRedo">
<button class="show-code">Code</button>
final bool         <strong>canRedo</strong> <a class="anchor-link"
            href="#canRedo"
            title="Permalink to Schedule.canRedo">#</a>
        </h4>
        <div class="doc">
<p>Whether or not the <a class="crossref" href="../undone/Schedule.html#redo">redo</a> method may be called at the present time.</p>
<pre class="source">
bool get canRedo =&gt; !busy &amp;&amp; _canRedo;
</pre>
</div>
</div>
<div class="field"><h4 id="canUndo">
<button class="show-code">Code</button>
final bool         <strong>canUndo</strong> <a class="anchor-link"
            href="#canUndo"
            title="Permalink to Schedule.canUndo">#</a>
        </h4>
        <div class="doc">
<p>Whether or not the <a class="crossref" href="../undone/Schedule.html#undo">undo</a> method may be called at the present time.</p>
<pre class="source">
bool get canUndo =&gt; !busy &amp;&amp; _canUndo;
</pre>
</div>
</div>
<div class="field"><h4 id="error">
<button class="show-code">Code</button>
final         <strong>error</strong> <a class="anchor-link"
            href="#error"
            title="Permalink to Schedule.error">#</a>
        </h4>
        <div class="doc">
<p>The current error, if <a class="crossref" href="../undone/Schedule.html#hasError">hasError</a> is <code>true</code>.  This schedule will remain
<a class="crossref" href="../undone/Schedule.html#busy">busy</a> for as long as this schedule <a class="crossref" href="../undone/Schedule.html#hasError">hasError</a>.  You may <a class="crossref" href="../undone/Schedule.html#clear">clear</a> this
schedule after dealing with the error condition in order to use it again.</p>
<pre class="source">
get error =&gt; _err;
</pre>
</div>
</div>
<div class="field"><h4 id="hasError">
<button class="show-code">Code</button>
final bool         <strong>hasError</strong> <a class="anchor-link"
            href="#hasError"
            title="Permalink to Schedule.hasError">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule has an <a class="crossref" href="../undone/Schedule.html#error">error</a>.</p>
<pre class="source">
bool get hasError =&gt; _state == STATE_ERROR;
</pre>
</div>
</div>
<div class="field"><h4 id="states">
<button class="show-code">Code</button>
final Stream&lt;String&gt;         <strong>states</strong> <a class="anchor-link"
            href="#states"
            title="Permalink to Schedule.states">#</a>
        </h4>
        <div class="doc">
<p>An observable stream of this schedule's state transitions.</p>
<pre class="source">
Stream&lt;String&gt; get states =&gt; _states.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="call">
<button class="show-code">Code</button>
Future <strong>call</strong>(<a href="../undone/Action.html">Action</a> action) <a class="anchor-link" href="#call"
              title="Permalink to Schedule.call">#</a></h4>
<div class="doc">
<p>Schedule the given 
<span class="param">action</span> to be called.  If this schedule is not <a class="crossref" href="../undone/Schedule.html#busy">busy</a>, 
the action will be called immediately.  Else, the action will be deferred 
in order behind any other pending actions to be called once this schedule 
reaches an idle state.</p>
<pre class="source">
Future call(Action action) {
 if (hasError) {
   _error = new StateError('Cannot call if Schedule.hasError.');
   return new Future.error(error); 
 }
 if (_actions.contains(action) || _pending.contains(action)) {
   _error = new StateError('Cannot call $action &gt;1 time on same schedule.');
   return new Future.error(error);
 }
 if (busy) {
   _log(() =&gt; 'defer $action');
   _pending.add(action);
   return action._defer();
 }
 _state = STATE_CALL;
 return _do(action);
}
</pre>
</div>
</div>
<div class="method"><h4 id="clear">
<button class="show-code">Code</button>
bool <strong>clear</strong>() <a class="anchor-link" href="#clear"
              title="Permalink to Schedule.clear">#</a></h4>
<div class="doc">
<p>Clears this schedule if <a class="crossref" href="../undone/Schedule.html#canClear">canClear</a> is <code>true</code> at this time and returns
<code>true</code> if the operation succeeds or <code>false</code> if it does not succeed.</p>
<pre class="source">
bool clear() {
 if (!canClear) return false;
 _log(() =&gt; 'clear');
 _actions.clear();
 _pending.clear();
 _nextUndo = -1;
 // Force the state back to STATE_IDLE even if we were in STATE_ERROR.
 if (_currState != STATE_IDLE) {
   _currState = STATE_IDLE;
   if (_states.hasListener) _states.add(_currState);
 }
 _err = null;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="redo">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>redo</strong>() <a class="anchor-link" href="#redo"
              title="Permalink to Schedule.redo">#</a></h4>
<div class="doc">
<p>Redo the next action to be redone in this schedule, if any.
Completes <code>true</code> if an action was redone or else completes <code>false</code>.</p>
<pre class="source">
Future&lt;bool&gt; redo() { 
 var completer = new Completer&lt;bool&gt;();
 if(!_canRedo || !(_state == STATE_TO || _state == STATE_IDLE)) {
   _log(() =&gt; 'can not redo');
   completer.complete(false);
 } else {
   if (_state == STATE_IDLE) _state = STATE_REDO;
   final action = _actions[++_nextUndo];
   _log(() =&gt; 'execute ${action} [${_nextUndo-1}]');
   action._execute()
     .then((result) {
       _log(() =&gt; '${action} execute complete w/ $result');
       action._result = result;
       // Don't flush if we are in STATE_TO, it will flush when it is done.
       if (_state == STATE_REDO) completer.future.whenComplete(_flush);
       // Complete before we flush pending and transition to idle.
       // This ensures that continuations of redo see the state as the 
       // result of redo and _not_ the state of further pending actions. 
       completer.complete(true);          
     })
     .catchError((e) {
       _error = e;
       completer.completeError(e);
     });
 }
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="to">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>to</strong>(action) <a class="anchor-link" href="#to"
              title="Permalink to Schedule.to">#</a></h4>
<div class="doc">
<p>Undo or redo all ordered actions in this schedule until the given 
<span class="param">action</span> 
is done.  The state of the schedule after this operation is equal to the 
state upon completion of the given action. Completes <code>false</code> if any undo 
or redo operations performed complete <code>false</code>, if the schedule does not 
contain the given action, or if the schedule is <a class="crossref" href="../undone/Schedule.html#busy">busy</a>.</p>
<pre class="source">
Future&lt;bool&gt; to(action) { 
 var completer = new Completer();    
 if (!_actions.contains(action) || 
     !(_state == STATE_TO || _state == STATE_IDLE)) {
   completer.complete(false);
 } else {      
   _state = STATE_TO;
   _to(action, completer);
 }
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="undo">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>undo</strong>() <a class="anchor-link" href="#undo"
              title="Permalink to Schedule.undo">#</a></h4>
<div class="doc">
<p>Undo the next action to be undone in this schedule, if any.
Completes <code>true</code> if an action was undone or else completes <code>false</code>.</p>
<pre class="source">
Future&lt;bool&gt; undo() { 
 var completer = new Completer&lt;bool&gt;();
 if(!_canUndo || !(_state == STATE_TO || _state == STATE_IDLE)) {
   _log(() =&gt; 'can not undo');
   completer.complete(false);
 } else {
   if (_state == STATE_IDLE) _state = STATE_UNDO;      
   final action = _actions[_nextUndo--];
   _log(() =&gt; 'unexecute ${action} [${_nextUndo+1}]');
   action._unexecute()
     .then((_) {
       _log(() =&gt; '${action} unexecute complete');
       // Don't flush if we are in STATE_TO, it will flush when it is done.
       if (_state == STATE_UNDO) completer.future.whenComplete(_flush);
       // Complete before we flush pending and transition to idle.
       // This ensures that continuations of undo see the state as the 
       // result of undo and _not_ the state of further pending actions. 
       completer.complete(true);          
     })
     .catchError((e) {
       _error = e;
       completer.completeError(e);
     });
 }
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="wait">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>wait</strong>(String state) <a class="anchor-link" href="#wait"
              title="Permalink to Schedule.wait">#</a></h4>
<div class="doc">
<p>Wait for this schedule to reach the given 
<span class="param">state</span>.
Completes on the next transition to the given state, or immediately if the 
state is the current state of this schedule.</p>
<pre class="source">
Future&lt;String&gt; wait(String state) {
 // TODO(rms): validate that state is one of the possible values; oh enum!
 if (_state == state) return new Future.value(_state);
 return states.firstWhere((s) =&gt; s == state);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-05 07:41:18.166</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
