        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Schedule class / undone Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="undone" data-type="Schedule">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../undone.html">undone</a> &rsaquo; <a href="../undone/Schedule.html">Schedule</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Schedule</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An asynchronous schedule of actions.</p>
<p>A schedule is a function that can be <a class="crossref" href="../undone/Schedule.html#call">call</a>ed with <a class="crossref" href="../undone/Action.html">Action</a>s.  The order 
of such calls is preserved in a history to allow for <a class="crossref" href="../undone/Schedule.html#undo">undo</a> and <a class="crossref" href="../undone/Schedule.html#redo">redo</a>.  An 
action may be scheduled at any time; if the schedule <a class="crossref" href="../undone/Schedule.html#isIdle">isIdle</a> then it will 
be called immediately, otherwise it will be queued to be called as soon 
as possible.  Methods to change the history such as <a class="crossref" href="../undone/Schedule.html#undo">undo</a> and <a class="crossref" href="../undone/Schedule.html#redo">redo</a> can 
<em>not</em> be invoked when the schedule <a class="crossref" href="../undone/Schedule.html#isBusy">isBusy</a>.  This ensures that all queued 
actions are called and the schedule reaches an idle state before the history 
may be modified.  Each schedule is a state machine, and its <a class="crossref" href="../undone/Schedule.html#states">states</a> are 
observable as a stream; this provides a convenient means to connect a user 
interface to the history control methods.</p>
<pre class="source">
class Schedule {
 
 /// A schedule is idle (not busy).
 static const String STATE_IDLE = 'IDLE';
 
 /// A schedule is busy executing a new action.
 static const String STATE_CALL = 'CALL';
 
 /// A schedule is busy flushing pending actions.
 static const String STATE_FLUSH = 'FLUSH';
 
 /// A schedule is busy performing a redo operation.
 static const String STATE_REDO = 'REDO';
 
 /// A schedule is busy performing an undo operation.
 static const String STATE_UNDO = 'UNDO';
 
 /// A schedule is busy performing a to operation.
 static const String STATE_TO = 'TO';
 
 /// A schedule has an error.
 static const String STATE_ERROR = 'ERROR';
 
 static const List&lt;String&gt; _STATES = 
     const [ STATE_IDLE, 
             STATE_CALL, 
             STATE_FLUSH, 
             STATE_REDO, 
             STATE_UNDO, 
             STATE_TO, 
             STATE_ERROR ];
 
 final _actions = new List&lt;Action&gt;();
 // Actions that are called while this schedule is busy are pending to be done.
 final _pending = new List&lt;Action&gt;();
 int _nextUndo = -1;
 String _currState = STATE_IDLE;
 var _err;
 var _stackTrace;
 
 /// Whether or not this schedule is busy performing another action.
 /// 
 /// This is always `true` when called from any continuations that are
 /// chained to Futures returned by methods on this schedule.
 /// This is also `true` if this schedule has an [error].
 /// 
 /// This is equivalent to `!isIdle`.
 bool get isBusy =&gt; !isIdle;
 
 /// Whether or not this schedule is in its [STATE_IDLE].
 /// 
 /// This is equivalent to `!isBusy`.
 bool get isIdle =&gt; _state == STATE_IDLE;
   
 /// Whether or not this schedule can be [clear]ed at the present time.
 bool get canClear =&gt; isIdle || hasError;
 
 bool get _canRedo =&gt; _nextUndo &lt; _actions.length - 1;
 /// Whether or not the [redo] method may be called at the present time.
 bool get canRedo =&gt; isIdle &amp;&amp; _canRedo;
 
 bool get _canUndo =&gt; _nextUndo &gt;= 0;
 /// Whether or not the [undo] method may be called at the present time.
 bool get canUndo =&gt; isIdle &amp;&amp; _canUndo;
 
 /// Whether or not this schedule has an [error].
 bool get hasError =&gt; _state == STATE_ERROR;
   
 /// The current error, if [hasError] is `true`.  
 /// 
 /// Calling [isBusy] on this schedule will return `true` for as long as this 
 /// schedule [hasError].  You may [clear] this schedule after dealing with the
 /// error condition in order to use it again.
 get error =&gt; _err;
 
 /// The current [error]'s stack trace, if [hasError] is `true` and a stack
 /// trace is available.
 get stackTrace =&gt; _stackTrace;
 
 void _error(e, [stackTrace]) {
   _err = e;
   _stackTrace = stackTrace;
   _state = STATE_ERROR;    
   _logError(e, stackTrace);
 }
 
 // The current state of this schedule.
 String 
   get _state =&gt; _currState;
   set _state(String nextState) {
     if (nextState != _currState &amp;&amp; _currState != STATE_ERROR) {
       _currState = nextState;
       _logFine('--- enter state ---');
       if (_states.hasListener) _states.add(_currState);
     }
   }
   
 final _states = new StreamController&lt;String&gt;.broadcast();
 /// An observable stream of this schedule's state transitions.
 Stream&lt;String&gt; get states =&gt; _states.stream;
   
 /// Schedule the given [action] to be called.  
 /// 
 /// If this schedule [isIdle], the action will be called immediately.  Else, 
 /// the action will be deferred in order behind any other pending actions to 
 /// be called once this schedule reaches an idle state.
 Future call(Action action) {
   if (hasError) {
     _error(new StateError('Cannot call if Schedule.hasError.'));
     return new Future.error(error); 
   }
   if (_actions.contains(action) || _pending.contains(action)) {
     _error(new StateError('Cannot call $action &gt;1 time on same schedule.'));
     return new Future.error(error);
   }
   if (isBusy) {
     _logFine('defer $action');
     _pending.add(action);
     return action._defer();
   }
   _state = STATE_CALL;
   return _do(action);
 }
 
 /// Clears this schedule if [canClear] is `true` at this time and returns
 /// `true` if the operation succeeds or `false` if it does not succeed.
 bool clear() {
   if (!canClear) return false;
   _logFine('clear');
   _actions.clear();
   _pending.clear();
   _nextUndo = -1;
   // Force the state back to STATE_IDLE even if we were in STATE_ERROR.
   if (_currState != STATE_IDLE) {
     _currState = STATE_IDLE;
     if (_states.hasListener) _states.add(_currState);
   }
   _err = null;
   _stackTrace = null;
   return true;
 }
 
 Future _do(action) {    
   var completer = new Completer();
   if (action.canUndo) {
     // Truncate the end of list (redo actions) when adding a new action.
     if (_nextUndo &gt;= 0) _actions.removeRange(_nextUndo, _actions.length - 1);
     _actions.add(action);        
     _nextUndo++;
     _logFine('execute undoable $action [$_nextUndo]');
   } else {
     _logFine('execute non-undoable $action');
   }
   action._execute()
     .then((result) {
       _logFine('$action complete w/ $result');
       action._result = result;
       // Flush any pending action calls that were deferred as we did this 
       // action.  Also flush if we see STATE_ERROR, to ensure that pending
       // actions that were called prior to the error receive a completion.
       if (_state == STATE_CALL || _state == STATE_ERROR) {
         completer.future.whenComplete(_flush);        
       }
       // Complete the result before we flush pending and transition to idle.
       // This ensures 2 things:
       //    1) The continuations of the action see the state as the result of 
       //       this action and _not_ the state of further pending actions.
       //    2) The order of pending actions is preserved as the user is not
       //       able to undo or redo (busy == true) in continuations.
       completer.complete(result);        
     })
     .catchError((e, stackTrace) {
       _error(e, stackTrace);
       completer.completeError(e, stackTrace);
     });    
   return completer.future;    
 }
 
 Future _flush() {
   // If nothing is pending then complete immediate and go to STATE_IDLE.
   if (_pending.isEmpty) {
     _state = STATE_IDLE;
     return new Future.value();
   }
   _state = STATE_FLUSH;
   // Copy _pending actions to a new list to iterate because new actions 
   // may be added to _pending while we are iterating.
   final _flushing = _pending.toList();
   _pending.clear();
   _logFine('flushing ${_flushing.length} actions');
   return Future
     .forEach(_flushing, (action) =&gt; _do(action)) 
     .then((_) {        
       // If we get new _pending actions during flush we want to flush again.
       if (!_pending.isEmpty) {
         _logFine('new actions pending - flushing again');
         return _flush();
       } else {
         _logFine('flush complete');
         _state = STATE_IDLE;
       }
     })
     // The action will complete the error to its continuations, but we will 
     // also receive it here in order to transition to the error state.
     .catchError((e, stackTrace) =&gt; _error(e, stackTrace));
 }
     
 void _log(Level level, String message, [error, stackTrace]) {
   _logger.log(level, '[$_state]: $message', error, stackTrace);
 }
 
 void _logFine(String message) =&gt; _log(Level.FINE, message);
 void _logError(error, [stackTrace]) =&gt; 
     _log(Level.SEVERE, Error.safeToString(error), error, stackTrace);
 
 /// Redo the next action to be redone in this schedule, if any.
 /// 
 /// Completes `true` if an action was redone or else completes `false`.
 Future&lt;bool&gt; redo() { 
   var completer = new Completer&lt;bool&gt;();
   if(!_canRedo || !(_state == STATE_TO || _state == STATE_IDLE)) {
     _logFine('can not redo');
     completer.complete(false);
   } else {
     if (_state == STATE_IDLE) _state = STATE_REDO;
     final action = _actions[++_nextUndo];
     _logFine('execute $action [${_nextUndo-1}]');
     action._execute()
       .then((result) {
         _logFine('$action execute complete w/ $result');
         action._result = result;
         // Don't flush if we are in STATE_TO, it will flush when it is done.
         if (_state == STATE_REDO) completer.future.whenComplete(_flush);
         // Complete before we flush pending and transition to idle.
         // This ensures that continuations of redo see the state as the 
         // result of redo and _not_ the state of further pending actions. 
         completer.complete(true);          
       })
       .catchError((e, stackTrace) {
         _error(e, stackTrace);
         completer.completeError(e, stackTrace);
       });
   }
   return completer.future;
 }
 
 /// Undo or redo all ordered actions in this schedule until the given [action] 
 /// is done.  
 /// 
 /// The state of the schedule after this operation is equal to the state upon 
 /// completion of the given action. Completes `false` if any undo or redo 
 /// operations performed complete `false`, if the schedule does not contain 
 /// the given action, or if the schedule [isBusy].
 Future&lt;bool&gt; to(action) { 
   var completer = new Completer();    
   if (!_actions.contains(action) || 
       !(_state == STATE_TO || _state == STATE_IDLE)) {
     completer.complete(false);
   } else {      
     _state = STATE_TO;
     _to(action, completer);
   }
   return completer.future;
 }
 
 void _to(action, completer) {
   final handleError = (e, stackTrace) { 
     _error(e, stackTrace);
     completer.completeError(e, stackTrace); 
   };
   final int actionIndex = _actions.indexOf(action);
   if (actionIndex == _nextUndo) {
     completer.future.whenComplete(_flush);
     // Complete before we flush pending and transition to idle.
     // This ensures that continuations of 'to' see the state as the 
     // result of 'to' and _not_ the state of further pending actions.
     completer.complete(true);
   } else if (actionIndex &lt; _nextUndo) {
     // Undo towards the desired action.
     undo()
       .then((success) {
         if (!success) {
           completer.complete(false);
         } else {
           _to(action, completer);
         }
       })
       .catchError(handleError);
   } else {
     // Redo towards the desired action.
     redo()
       .then((success) {
         if (!success) {
           completer.complete(false); 
         } else {
           _to(action, completer);
         }
       })
       .catchError(handleError);
   }
 }
 
 /// Undo the next action to be undone in this schedule, if any.
 /// Completes `true` if an action was undone or else completes `false`.
 Future&lt;bool&gt; undo() { 
   var completer = new Completer&lt;bool&gt;();
   if(!_canUndo || !(_state == STATE_TO || _state == STATE_IDLE)) {
     _logFine('can not undo');
     completer.complete(false);
   } else {
     if (_state == STATE_IDLE) _state = STATE_UNDO;      
     final action = _actions[_nextUndo--];
     _logFine('unexecute $action [${_nextUndo+1}]');
     action._unexecute()
       .then((_) {
         _logFine('$action unexecute complete');
         // Don't flush if we are in STATE_TO, it will flush when it is done.
         if (_state == STATE_UNDO) completer.future.whenComplete(_flush);
         // Complete before we flush pending and transition to idle.
         // This ensures that continuations of undo see the state as the 
         // result of undo and _not_ the state of further pending actions. 
         completer.complete(true);          
       })
       .catchError((e, stackTrace) {
         _error(e, stackTrace);
         completer.completeError(e, stackTrace);
       });
   }
   return completer.future;
 }
 
 /// Wait for this schedule to reach the given [state].
 /// 
 /// Completes on the next transition to the given state, or immediately if the 
 /// state is the current state of this schedule.  Completes an [ArgumentError]
 /// if the given [state] is not valid.
 Future&lt;String&gt; wait(String state) {
   if (!_STATES.contains(state)) {
     return new Future.error(
         new ArgumentError('$state is not a valid state.'));
   }
   if (_state == state) {
     return new Future.value(_state);  
   }
   return states.firstWhere((s) =&gt; s == state);
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="STATE_CALL">
<button class="show-code">Code</button>
const String         <strong>STATE_CALL</strong> <a class="anchor-link"
            href="#STATE_CALL"
            title="Permalink to Schedule.STATE_CALL">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy executing a new action.</p>
<pre class="source">
static const String STATE_CALL = 'CALL'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_ERROR">
<button class="show-code">Code</button>
const String         <strong>STATE_ERROR</strong> <a class="anchor-link"
            href="#STATE_ERROR"
            title="Permalink to Schedule.STATE_ERROR">#</a>
        </h4>
        <div class="doc">
<p>A schedule has an error.</p>
<pre class="source">
static const String STATE_ERROR = 'ERROR'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_FLUSH">
<button class="show-code">Code</button>
const String         <strong>STATE_FLUSH</strong> <a class="anchor-link"
            href="#STATE_FLUSH"
            title="Permalink to Schedule.STATE_FLUSH">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy flushing pending actions.</p>
<pre class="source">
static const String STATE_FLUSH = 'FLUSH'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_IDLE">
<button class="show-code">Code</button>
const String         <strong>STATE_IDLE</strong> <a class="anchor-link"
            href="#STATE_IDLE"
            title="Permalink to Schedule.STATE_IDLE">#</a>
        </h4>
        <div class="doc">
<p>A schedule is idle (not busy).</p>
<pre class="source">
static const String STATE_IDLE = 'IDLE'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_REDO">
<button class="show-code">Code</button>
const String         <strong>STATE_REDO</strong> <a class="anchor-link"
            href="#STATE_REDO"
            title="Permalink to Schedule.STATE_REDO">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy performing a redo operation.</p>
<pre class="source">
static const String STATE_REDO = 'REDO'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_TO">
<button class="show-code">Code</button>
const String         <strong>STATE_TO</strong> <a class="anchor-link"
            href="#STATE_TO"
            title="Permalink to Schedule.STATE_TO">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy performing a to operation.</p>
<pre class="source">
static const String STATE_TO = 'TO'
</pre>
</div>
</div>
<div class="field"><h4 id="STATE_UNDO">
<button class="show-code">Code</button>
const String         <strong>STATE_UNDO</strong> <a class="anchor-link"
            href="#STATE_UNDO"
            title="Permalink to Schedule.STATE_UNDO">#</a>
        </h4>
        <div class="doc">
<p>A schedule is busy performing an undo operation.</p>
<pre class="source">
static const String STATE_UNDO = 'UNDO'
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="canClear">
<button class="show-code">Code</button>
final bool         <strong>canClear</strong> <a class="anchor-link"
            href="#canClear"
            title="Permalink to Schedule.canClear">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule can be <a class="crossref" href="../undone/Schedule.html#clear">clear</a>ed at the present time.</p>
<pre class="source">
bool get canClear =&gt; isIdle || hasError;
</pre>
</div>
</div>
<div class="field"><h4 id="canRedo">
<button class="show-code">Code</button>
final bool         <strong>canRedo</strong> <a class="anchor-link"
            href="#canRedo"
            title="Permalink to Schedule.canRedo">#</a>
        </h4>
        <div class="doc">
<p>Whether or not the <a class="crossref" href="../undone/Schedule.html#redo">redo</a> method may be called at the present time.</p>
<pre class="source">
bool get canRedo =&gt; isIdle &amp;&amp; _canRedo;
</pre>
</div>
</div>
<div class="field"><h4 id="canUndo">
<button class="show-code">Code</button>
final bool         <strong>canUndo</strong> <a class="anchor-link"
            href="#canUndo"
            title="Permalink to Schedule.canUndo">#</a>
        </h4>
        <div class="doc">
<p>Whether or not the <a class="crossref" href="../undone/Schedule.html#undo">undo</a> method may be called at the present time.</p>
<pre class="source">
bool get canUndo =&gt; isIdle &amp;&amp; _canUndo;
</pre>
</div>
</div>
<div class="field"><h4 id="error">
<button class="show-code">Code</button>
final         <strong>error</strong> <a class="anchor-link"
            href="#error"
            title="Permalink to Schedule.error">#</a>
        </h4>
        <div class="doc">
<p>The current error, if <a class="crossref" href="../undone/Schedule.html#hasError">hasError</a> is <code>true</code>.  </p>
<p>Calling <a class="crossref" href="../undone/Schedule.html#isBusy">isBusy</a> on this schedule will return <code>true</code> for as long as this 
schedule <a class="crossref" href="../undone/Schedule.html#hasError">hasError</a>.  You may <a class="crossref" href="../undone/Schedule.html#clear">clear</a> this schedule after dealing with the
error condition in order to use it again.</p>
<pre class="source">
get error =&gt; _err;
</pre>
</div>
</div>
<div class="field"><h4 id="hasError">
<button class="show-code">Code</button>
final bool         <strong>hasError</strong> <a class="anchor-link"
            href="#hasError"
            title="Permalink to Schedule.hasError">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule has an <a class="crossref" href="../undone/Schedule.html#error">error</a>.</p>
<pre class="source">
bool get hasError =&gt; _state == STATE_ERROR;
</pre>
</div>
</div>
<div class="field"><h4 id="isBusy">
<button class="show-code">Code</button>
final bool         <strong>isBusy</strong> <a class="anchor-link"
            href="#isBusy"
            title="Permalink to Schedule.isBusy">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule is busy performing another action.</p>
<p>This is always <code>true</code> when called from any continuations that are
chained to Futures returned by methods on this schedule.
This is also <code>true</code> if this schedule has an <a class="crossref" href="../undone/Schedule.html#error">error</a>.</p>
<p>This is equivalent to <code>!isIdle</code>.</p>
<pre class="source">
bool get isBusy =&gt; !isIdle;
</pre>
</div>
</div>
<div class="field"><h4 id="isIdle">
<button class="show-code">Code</button>
final bool         <strong>isIdle</strong> <a class="anchor-link"
            href="#isIdle"
            title="Permalink to Schedule.isIdle">#</a>
        </h4>
        <div class="doc">
<p>Whether or not this schedule is in its <a class="crossref" href="../undone/Schedule.html#STATE_IDLE">STATE_IDLE</a>.</p>
<p>This is equivalent to <code>!isBusy</code>.</p>
<pre class="source">
bool get isIdle =&gt; _state == STATE_IDLE;
</pre>
</div>
</div>
<div class="field"><h4 id="stackTrace">
<button class="show-code">Code</button>
final         <strong>stackTrace</strong> <a class="anchor-link"
            href="#stackTrace"
            title="Permalink to Schedule.stackTrace">#</a>
        </h4>
        <div class="doc">
<p>The current <a class="crossref" href="../undone/Schedule.html#error">error</a>'s stack trace, if <a class="crossref" href="../undone/Schedule.html#hasError">hasError</a> is <code>true</code> and a stack
trace is available.</p>
<pre class="source">
get stackTrace =&gt; _stackTrace;
</pre>
</div>
</div>
<div class="field"><h4 id="states">
<button class="show-code">Code</button>
final Stream&lt;String&gt;         <strong>states</strong> <a class="anchor-link"
            href="#states"
            title="Permalink to Schedule.states">#</a>
        </h4>
        <div class="doc">
<p>An observable stream of this schedule's state transitions.</p>
<pre class="source">
Stream&lt;String&gt; get states =&gt; _states.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="call">
<button class="show-code">Code</button>
Future <strong>call</strong>(<a href="../undone/Action.html">Action</a> action) <a class="anchor-link" href="#call"
              title="Permalink to Schedule.call">#</a></h4>
<div class="doc">
<p>Schedule the given 
<span class="param">action</span> to be called.  </p>
<p>If this schedule <a class="crossref" href="../undone/Schedule.html#isIdle">isIdle</a>, the action will be called immediately.  Else, 
the action will be deferred in order behind any other pending actions to 
be called once this schedule reaches an idle state.</p>
<pre class="source">
Future call(Action action) {
 if (hasError) {
   _error(new StateError('Cannot call if Schedule.hasError.'));
   return new Future.error(error); 
 }
 if (_actions.contains(action) || _pending.contains(action)) {
   _error(new StateError('Cannot call $action &gt;1 time on same schedule.'));
   return new Future.error(error);
 }
 if (isBusy) {
   _logFine('defer $action');
   _pending.add(action);
   return action._defer();
 }
 _state = STATE_CALL;
 return _do(action);
}
</pre>
</div>
</div>
<div class="method"><h4 id="clear">
<button class="show-code">Code</button>
bool <strong>clear</strong>() <a class="anchor-link" href="#clear"
              title="Permalink to Schedule.clear">#</a></h4>
<div class="doc">
<p>Clears this schedule if <a class="crossref" href="../undone/Schedule.html#canClear">canClear</a> is <code>true</code> at this time and returns
<code>true</code> if the operation succeeds or <code>false</code> if it does not succeed.</p>
<pre class="source">
bool clear() {
 if (!canClear) return false;
 _logFine('clear');
 _actions.clear();
 _pending.clear();
 _nextUndo = -1;
 // Force the state back to STATE_IDLE even if we were in STATE_ERROR.
 if (_currState != STATE_IDLE) {
   _currState = STATE_IDLE;
   if (_states.hasListener) _states.add(_currState);
 }
 _err = null;
 _stackTrace = null;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="redo">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>redo</strong>() <a class="anchor-link" href="#redo"
              title="Permalink to Schedule.redo">#</a></h4>
<div class="doc">
<p>Redo the next action to be redone in this schedule, if any.</p>
<p>Completes <code>true</code> if an action was redone or else completes <code>false</code>.</p>
<pre class="source">
Future&lt;bool&gt; redo() { 
 var completer = new Completer&lt;bool&gt;();
 if(!_canRedo || !(_state == STATE_TO || _state == STATE_IDLE)) {
   _logFine('can not redo');
   completer.complete(false);
 } else {
   if (_state == STATE_IDLE) _state = STATE_REDO;
   final action = _actions[++_nextUndo];
   _logFine('execute $action [${_nextUndo-1}]');
   action._execute()
     .then((result) {
       _logFine('$action execute complete w/ $result');
       action._result = result;
       // Don't flush if we are in STATE_TO, it will flush when it is done.
       if (_state == STATE_REDO) completer.future.whenComplete(_flush);
       // Complete before we flush pending and transition to idle.
       // This ensures that continuations of redo see the state as the 
       // result of redo and _not_ the state of further pending actions. 
       completer.complete(true);          
     })
     .catchError((e, stackTrace) {
       _error(e, stackTrace);
       completer.completeError(e, stackTrace);
     });
 }
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="to">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>to</strong>(action) <a class="anchor-link" href="#to"
              title="Permalink to Schedule.to">#</a></h4>
<div class="doc">
<p>Undo or redo all ordered actions in this schedule until the given 
<span class="param">action</span> 
is done.  </p>
<p>The state of the schedule after this operation is equal to the state upon 
completion of the given action. Completes <code>false</code> if any undo or redo 
operations performed complete <code>false</code>, if the schedule does not contain 
the given action, or if the schedule <a class="crossref" href="../undone/Schedule.html#isBusy">isBusy</a>.</p>
<pre class="source">
Future&lt;bool&gt; to(action) { 
 var completer = new Completer();    
 if (!_actions.contains(action) || 
     !(_state == STATE_TO || _state == STATE_IDLE)) {
   completer.complete(false);
 } else {      
   _state = STATE_TO;
   _to(action, completer);
 }
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="undo">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>undo</strong>() <a class="anchor-link" href="#undo"
              title="Permalink to Schedule.undo">#</a></h4>
<div class="doc">
<p>Undo the next action to be undone in this schedule, if any.
Completes <code>true</code> if an action was undone or else completes <code>false</code>.</p>
<pre class="source">
Future&lt;bool&gt; undo() { 
 var completer = new Completer&lt;bool&gt;();
 if(!_canUndo || !(_state == STATE_TO || _state == STATE_IDLE)) {
   _logFine('can not undo');
   completer.complete(false);
 } else {
   if (_state == STATE_IDLE) _state = STATE_UNDO;      
   final action = _actions[_nextUndo--];
   _logFine('unexecute $action [${_nextUndo+1}]');
   action._unexecute()
     .then((_) {
       _logFine('$action unexecute complete');
       // Don't flush if we are in STATE_TO, it will flush when it is done.
       if (_state == STATE_UNDO) completer.future.whenComplete(_flush);
       // Complete before we flush pending and transition to idle.
       // This ensures that continuations of undo see the state as the 
       // result of undo and _not_ the state of further pending actions. 
       completer.complete(true);          
     })
     .catchError((e, stackTrace) {
       _error(e, stackTrace);
       completer.completeError(e, stackTrace);
     });
 }
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="wait">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>wait</strong>(String state) <a class="anchor-link" href="#wait"
              title="Permalink to Schedule.wait">#</a></h4>
<div class="doc">
<p>Wait for this schedule to reach the given 
<span class="param">state</span>.</p>
<p>Completes on the next transition to the given state, or immediately if the 
state is the current state of this schedule.  Completes an <a class="crossref" href="../dart_core/ArgumentError.html">ArgumentError</a>
if the given 
<span class="param">state</span> is not valid.</p>
<pre class="source">
Future&lt;String&gt; wait(String state) {
 if (!_STATES.contains(state)) {
   return new Future.error(
       new ArgumentError('$state is not a valid state.'));
 }
 if (_state == state) {
   return new Future.value(_state);  
 }
 return states.firstWhere((s) =&gt; s == state);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-11-10 17:46:55.220</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
