        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Action&lt;A, R&gt; class / undone Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="undone" data-type="Action&amp;lt;A, R&amp;gt;">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../undone.html">undone</a> &rsaquo; <a href="../undone/Action.html">Action&lt;A, R&gt;</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Action&lt;A, R&gt;</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An action that can be done and undone.</p>
<p>Actions are comprised of a pair of functions: one to <a class="crossref" href="../undone/Do.html">Do</a> the action and
another to <a class="crossref" href="../undone/Undo.html">Undo</a> the action.  The action object is itself a function that 
can be <a class="crossref" href="../undone/Action.html#call">call</a>ed to schedule it to be done on the top-level <a class="crossref" href="../undone.html#schedule">schedule</a> or
to add it to a <a class="crossref" href="../undone/Transaction.html">Transaction</a> if called within the scope of <a class="crossref" href="../undone.html#transact">transact</a>.
Actions may also be constructed with a pair of <a class="crossref" href="../undone/DoAsync.html">DoAsync</a> and <a class="crossref" href="../undone/UndoAsync.html">UndoAsync</a>
functions using the <a class="crossref" href="../undone/Action.html#Action.async">new Action.async</a> constructor.  All actions are done
and undone asynchronously, regardless of the functions themselves.  Actions
may be optionally typed by their argument and result objects, <code>A</code> and <code>R</code>.
The action type may be extended to define custom actions although this may
often not be necessary; constructing an action with the functions to do and
undo the desired operation is often the simplest and best approach.</p>
<pre class="source">
class Action&lt;A, R&gt; {
 final A _arg;
 R _result; // The result of the most recent call().
 final DoAsync _do;
 final UndoAsync _undo;
 Completer _deferred;
 
 /// Constructs a new action with the given [arg]uments, [Do] function, and 
 /// [Undo] function.  The given synchronous functions are automatically 
 /// wrapped in futures prior to being called on a schedule.
 Action(A arg, Do d, Undo u) : this._(arg,
   d == null ? d : (a) =&gt; new Future.of(() =&gt; d(a)), 
   u == null ? u : (a, r) =&gt; new Future.of(() =&gt; u(a, r)));
 
 /// Constructs a new action with the given [arg]uments, [DoAsync] function, 
 /// and [UndoAsync] function.
 Action.async(A arg, DoAsync d, UndoAsync u) : this._(arg, d, u);
 
 Action._(this._arg, this._do, this._undo) {
   if (_do == null) throw new ArgumentError('Do function must be !null.');
   if (_undo == null) throw new ArgumentError('Undo function must be !null.');
 }
 
 /// Schedules this action to be called on the top-level [schedule].  If this
 /// action is called within the scope of a top-level [transact] method it will
 /// instead be added to that transaction.  Completes with the result of the
 /// action in both cases.
 Future&lt;R&gt; call() {    
   if (_transaction != null) {
     _transaction.add(this);
     return this._defer();
   }
   return schedule(this);
 }
 
 Future&lt;R&gt; _defer() {    
   // The action may only give out 1 deferred future at a time.
   assert(_deferred == null);
   _deferred = new Completer&lt;R&gt;();
   return _deferred.future;
 }
 
 Future&lt;R&gt; _execute() {
   if (_deferred == null) return _do(_arg);
   else {
     // If the action was deferred, we complete the future we handed out prior.
     return _do(_arg)
       .then((result) =&gt; _deferred.complete(result))
       .catchError(
           (e) { throw new StateError('Error wrongfully caught.'); }, 
           test: (e) {
             // Complete the error to the deferred future, but allow the error
             // to propogate back to the schedule also so that it can 
             // transition to its error state.
             _deferred.completeError(e);
             return false;
           })
       .whenComplete(() =&gt; _deferred = null);
   }
 }
 
 Future _unexecute() =&gt; _undo(_arg, _result);  
}
</pre>
</div>
<h3>Subclasses</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../undone/Transaction.html">Transaction</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Action">
<button class="show-code">Code</button>
new <strong>Action</strong>(<a href="../undone/Action.html">A</a> arg, <a href="../undone/Do.html">Do</a> d, <a href="../undone/Undo.html">Undo</a> u) <a class="anchor-link" href="#Action"
              title="Permalink to Action&lt;A, R&gt;.Action">#</a></h4>
<div class="doc">
<p>Constructs a new action with the given 
<span class="param">arg</span>uments, <a class="crossref" href="../undone/Do.html">Do</a> function, and 
<a class="crossref" href="../undone/Undo.html">Undo</a> function.  The given synchronous functions are automatically 
wrapped in futures prior to being called on a schedule.</p>
<pre class="source">
Action(A arg, Do d, Undo u) : this._(arg,
 d == null ? d : (a) =&gt; new Future.of(() =&gt; d(a)), 
 u == null ? u : (a, r) =&gt; new Future.of(() =&gt; u(a, r)));
</pre>
</div>
</div>
<div class="method"><h4 id="Action.async">
<button class="show-code">Code</button>
new <strong>Action.async</strong>(<a href="../undone/Action.html">A</a> arg, <a href="../undone/DoAsync.html">DoAsync</a> d, <a href="../undone/UndoAsync.html">UndoAsync</a> u) <a class="anchor-link" href="#Action.async"
              title="Permalink to Action&lt;A, R&gt;.Action.async">#</a></h4>
<div class="doc">
<p>Constructs a new action with the given 
<span class="param">arg</span>uments, <a class="crossref" href="../undone/DoAsync.html">DoAsync</a> function, 
and <a class="crossref" href="../undone/UndoAsync.html">UndoAsync</a> function.</p>
<pre class="source">
Action.async(A arg, DoAsync d, UndoAsync u) : this._(arg, d, u);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="call">
<button class="show-code">Code</button>
Future&lt;<a href="../undone/Action.html">R</a>&gt; <strong>call</strong>() <a class="anchor-link" href="#call"
              title="Permalink to Action&lt;A, R&gt;.call">#</a></h4>
<div class="doc">
<p>Schedules this action to be called on the top-level <a class="crossref" href="../undone.html#schedule">schedule</a>.  If this
action is called within the scope of a top-level <a class="crossref" href="../undone.html#transact">transact</a> method it will
instead be added to that transaction.  Completes with the result of the
action in both cases.</p>
<pre class="source">
Future&lt;R&gt; call() {    
 if (_transaction != null) {
   _transaction.add(this);
   return this._defer();
 }
 return schedule(this);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-03-25 01:13:24.160</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
